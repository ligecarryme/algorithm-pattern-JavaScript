### 二叉树

#### 二叉树遍历

**前序遍历**：**先访问根节点**，再前序遍历左子树，再前序遍历右子树 **中序遍历**：先中序遍历左子树，**再访问根节点**，再中序遍历右子树 **后序遍历**：先后序遍历左子树，再后序遍历右子树，**再访问根节点**。

注意点：

- 以根访问顺序决定是什么遍历
- 左子树都是优先右子树

##### 树结构

```js
function TreeNode(val){
    this.val = val;
    this.left = this.right = null;
}
```

##### 根据数组构建二叉树

```js
const buildTreeByArray = function (array, index) {
    let tn = null;
    if (index < array.length) {
        const value = array[index];
        if (value !== null) {
            tn = new TreeNode(value);
            tn.left = buildTreeByArray(array, 2 * index + 1);
            tn.right = buildTreeByArray(array, 2 * index + 2);
        }
        return tn;
    }
    return tn;
}

const binaryTree = function (array) {
    return buildTreeByArray(array, 0);
}

let arr = [1,2,3,null,4,5,null,null,null,6,7];
let root = binaryTree(arr);
```

##### 前序递归

```js
function preOrder(root) {
    if(root === null){
        return null;
    }
    console.log(root.val);
    preOrder(root.left);
    preOrder(root.right);
}
```

##### 前序非递归

```js
var preOrderTraversal = function (root) {
    if(root === null){
        return [];
    }
    let res = [];
    let stack = [];
    stack.push(root);
    while(stack.length !== 0){
        let node = stack.pop();
        res.push(node.val);
        if (node.right !== null) {
            stack.push(node.right);
        }
        if (node.left !== null) {
            stack.push(node.left);
        }
    }
    return res;
}
```

##### 中序递归

```js
function inOrder(root){
    if(root === null){
        return null;
    }
    inOrder(root.left);
    console.log(root.val);
    inOrder(root.right);
}
```

##### 中序非递归

```js
var inOrderTraversal = function(root){
    if (root === null) {
        return [];
    }
    let res = [];
    let stack = [];
    let node = root;
    while(stack.length!==0 || node!==null){
        while(node !== null){
            stack.push(node);
            node = node.left;
        }
        node = stack.pop();
        res.push(node.val);
        node = node.right;
    }
    return res;
}
```

##### 后序递归

```js
function postOrder(root){
    if(root === null){
        return null;
    }
    postOrder(root.left);
    postOrder(root.right);
    console.log(root.val);
}
```

##### 后序非递归

```js
var postOrderTraversal = function(root){  //翻转非递归 后序遍历
    if (root === null) {
        return [];
    }
    let res = [];
    let stack = [];
    stack.push(root);
    while(stack.length !== 0){
        let node = stack.pop();
        res.push(node.val);
        if (node.left !== null) {
            stack.push(node.left);
        }
        if (node.right !== null) {
            stack.push(node.right);
        }
    }
    return res.reverse();
}
```

##### 深度遍历

```js
var dfsUpToDown = function(root){  //递归，从上到下
    let res = [];
    dfs(root, res);
    return res;
}

var dfs = function(node, res){
    if (node === null) {
        return null;
    }
    res.push(node.val);
    dfs(node.left, res);
    dfs(node.right, res);
}

var dfsDownToUp = function(root){ //从下到上
    return divideAndConquer(root);
}

var divideAndConquer = function(node){ // 分治法
    let res = [];
    if (node === null) {
        return null;
    }
    let left = divideAndConquer(node.left);
    let right = divideAndConquer(node.right);
    res.push(node.val);
    if (left !== null) {
        res = res.concat(left.flat());
    }
    if (right !== null) {
        res = res.concat(right.flat());
    }
    return res;
}
```

##### 广度遍历

```js
var bfs = function(root){
    let res = [];
    let queue = [];
    queue.push(root);
    while(queue.length !== 0){
        let node = queue.shift();
        res.push(node.val);
        if (node.left !== null) {
            queue.push(node.left);
        }
        if (node.right !== null) {
            queue.push(node.right);
        }
    }
    return res;
}
```

##### 104.二叉树的最大深度[二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。**说明:** 叶子节点是指没有子节点的节点。

> 给定二叉树 [3,9,20,null,null,15,7]，
>
>       3
>      / \
>     9  20
>         /  \
>      15   7
>
> 返回它的最大深度 3 。

```js
var maxDepth = function(root) {   //递归
    if(root === null){
        return 0;
    }
    return Math.max(maxDepth(root.left), 								maxDepth(root.right))+1;
};
```

