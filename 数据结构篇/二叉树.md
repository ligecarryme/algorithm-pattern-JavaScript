### 二叉树

#### 二叉树遍历

**前序遍历**：**先访问根节点**，再前序遍历左子树，再前序遍历右子树 **中序遍历**：先中序遍历左子树，**再访问根节点**，再中序遍历右子树 **后序遍历**：先后序遍历左子树，再后序遍历右子树，**再访问根节点**。

注意点：

- 以根访问顺序决定是什么遍历
- 左子树都是优先右子树

##### 树结构

```js
function TreeNode(val){
    this.val = val;
    this.left = this.right = null;
}
```

##### 根据数组构建二叉树

```js
const buildTreeByArray = function (array, index) {
    let tn = null;
    if (index < array.length) {
        const value = array[index];
        tn = new TreeNode(value);
        tn.left = buildTreeByArray(array, 2 * index + 1);
        tn.right = buildTreeByArray(array, 2 * index + 2);
        return tn;
    }
    return tn;
}

const binaryTree = function (array) {
    return buildTreeByArray(array, 0);
}

let arr = [1,2,3,null,4,5,null,null,null,6,7];
let root = binaryTree(arr);
```

##### 前序递归

```js
function preOrder(root) {
    if(root === null || root.val === null){
        return null;
    }
    console.log(root.val);
    preOrder(root.left);
    preOrder(root.right);
}
```

##### 前序非递归

```js

```



##### 中序递归

```js
function inOrder(root){
    if(root === null || root.val === null){
        return null;
    }
    inOrder(root.left);
    console.log(root.val);
    inOrder(root.right);
}
```

##### 后序递归

```js
function postOrder(root){
    if(root === null || root.val === null){
        return null;
    }
    postOrder(root.left);
    postOrder(root.right);
    console.log(root.val);
}
```



##### 104.二叉树的最大深度[二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。**说明:** 叶子节点是指没有子节点的节点。

> 给定二叉树 [3,9,20,null,null,15,7]，
>
>       3
>      / \
>     9  20
>         /  \
>      15   7
>
> 返回它的最大深度 3 。

```js
var maxDepth = function(root) {   //递归
    if(root === null){
        return 0;
    }
    return Math.max(maxDepth(root.left), 				maxDepth(root.right))+1;
};
```

