### 二叉树

#### 二叉树遍历

**前序遍历**：**先访问根节点**，再前序遍历左子树，再前序遍历右子树 **中序遍历**：先中序遍历左子树，**再访问根节点**，再中序遍历右子树 **后序遍历**：先后序遍历左子树，再后序遍历右子树，**再访问根节点**。

注意点：

- 以根访问顺序决定是什么遍历
- 左子树都是优先右子树

##### 树结构

```js
function TreeNode(val){
    this.val = val;
    this.left = null;
    this.right = null;
}
```

##### 根据数组构建二叉树

```js
const buildTreeByArray = function (array, index) {
    let tn = null;
    if (index < array.length) {
        const value = array[index];
        if (value !== null) {
            tn = new TreeNode(value);
            tn.left = buildTreeByArray(array, 2 * index + 1);
            tn.right = buildTreeByArray(array, 2 * index + 2);
        }
        return tn;
    }
    return tn;
}

const binaryTree = function (array) {
    return buildTreeByArray(array, 0);
}

const arr = [1,2,3,null,4,5,null,null,null,6,7];
let root = binaryTree(arr);
```

##### 前序递归

```js
function preOrder(root) {
    if(root === null){
        return null;
    }
    console.log(root.val);
    preOrder(root.left);
    preOrder(root.right);
}
```

##### 前序非递归

```js
const preOrderTraversal = function (root) {
    if(root === null){
        return [];
    }
    const res = [];
    const stack = [];
    stack.push(root);
    while(stack.length !== 0){
        const node = stack.pop();
        res.push(node.val);
        if (node.right !== null) {
            stack.push(node.right);
        }
        if (node.left !== null) {
            stack.push(node.left);
        }
    }
    return res;
}
```

##### 中序递归

```js
function inOrder(root){
    if(root === null){
        return null;
    }
    inOrder(root.left);
    console.log(root.val);
    inOrder(root.right);
}
```

##### 中序非递归

```js
const inOrderTraversal = function(root){
    if (root === null) {
        return [];
    }
    const res = [];
    const stack = [];
    let node = root;
    while(stack.length!==0 || node!==null){
        while(node !== null){
            stack.push(node);
            node = node.left;
        }
        node = stack.pop();
        res.push(node.val);
        node = node.right;
    }
    return res;
}
```

##### 后序递归

```js
function postOrder(root){
    if(root === null){
        return null;
    }
    postOrder(root.left);
    postOrder(root.right);
    console.log(root.val);
}
```

##### 后序非递归

```js
const postOrderTraversal = function(root){  //翻转非递归 后序遍历
    if (root === null) {
        return [];
    }
    const res = [];
    const stack = [];
    stack.push(root);
    while(stack.length !== 0){
        let node = stack.pop();
        res.push(node.val);
        if (node.left !== null) {
            stack.push(node.left);
        }
        if (node.right !== null) {
            stack.push(node.right);
        }
    }
    return res.reverse();
}
```

##### 深度搜索

```js
const dfsUpToDown = function(root){  //递归，从上到下
    const res = [];
    dfs(root, res);
    return res;
}

const dfs = function(node, res){
    if (node === null) {
        return null;
    }
    res.push(node.val);
    dfs(node.left, res);
    dfs(node.right, res);
}

const dfsDownToUp = function(root){  //从下到上
    return divideAndConquer(root);
}

const divideAndConquer = function(node){  //分治法
    const res = [];
    if (node === null) {
        return null;
    }
    let left = divideAndConquer(node.left);
    let right = divideAndConquer(node.right);
    res.push(node.val);
    if (left !== null) {
        res = res.concat(left.flat());
    }
    if (right !== null) {
        res = res.concat(right.flat());
    }
    return res;
}
```

##### 广度搜索

```js
const bfs = function(root){
    let res = [];
    const queue = [];
    queue.push(root);
    while(queue.length !== 0){
        let node = queue.shift();
        res.push(node.val);
        if (node.left !== null) {
            queue.push(node.left);
        }
        if (node.right !== null) {
            queue.push(node.right);
        }
    }
    return res;
}
```

##### 104.[二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。**说明:** 叶子节点是指没有子节点的节点。

> 给定二叉树 [3,9,20,null,null,15,7]，
>
>       3
>      / \
>     9  20
>         /  \
>      15   7
>
> 返回它的最大深度 3 。

```js
const maxDepth = function(root) {   //递归
    if(root === null){
        return 0;
    }
    return Math.max(maxDepth(root.left), maxDepth(root.right))+1;
};
```

110.[平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

给定一个二叉树，判断它是否是高度平衡的二叉树。

```js
const isBalanced = function(root) {
    if(maxDepth(root) === -1) {
        return false
    }
    return true
};

const maxDepth = function(root) {
    if(root === null) {
        return 0
    }
    const left = maxDepth(root.left)
    const right = maxDepth(root.right)
    if(left === -1 || right === -1 || Math.abs(right - left) > 1) { //判断左右子树的高度
        return -1
    }
    if(left > right) {
        return left + 1
    }else{
        return right + 1
    }

}
```

124.[二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

**路径** 被定义为一条从树中任意节点出发，沿父节点—子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。

**路径和** 是路径中各节点值的总和。

给你一个二叉树的根节点 `root` ，返回其 **最大路径和** 。

> 思路：分治法，分为三种情况：左子树最大路径和最大，右子树最大路径和最大，左右子树最大加根节点最大，需要保存两个变量：一个保存子树最大路径和，一个保存左右加根节点和，然后比较这个两个变量选择最大值即可

```js
var maxPathSum = function (root) {
    let maxSum = Number.MIN_SAFE_INTEGER
    function maxGain(node) {
        if (!node) {
            return 0
        }
        const left = maxGain(node.left)
        const right = maxGain(node.right)
        maxSum = Math.max(maxSum, node.val, node.val + left + right, node.val + left, node.val + right)
        return Math.max(node.val, node.val + left, node.val + right)
    }
    maxGain(root)
    return maxSum
};
```

