## 栈和队列

### 简介

**栈**的特点是后入先出，根据这个特点可以临时保存一些数据，之后用到依次再弹出来，常用于 DFS 深度搜索

**队列**一般常用于 BFS 广度搜索，类似一层一层的搜索。

### Stack 栈

##### [155.最小栈](https://leetcode-cn.com/problems/min-stack/)

> 设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。

思路：用两个栈实现，一个最小栈始终保证最小值在顶部

```js
/**
 * initialize your data structure here.
 */
var MinStack = function() {
    this.stack = []; // JS用数组表示栈
    this.minStack = [Infinity];
};

/** 
 * @param {number} x
 * @return {void}
 */
MinStack.prototype.push = function(x) {
    this.stack.push(x);
    this.minStack.push(Math.min(this.minStack[this.minStack.length-1],x));
};

/**
 * @return {void}
 */
MinStack.prototype.pop = function() {
    this.stack.pop();
    this.minStack.pop();
};

/**
 * @return {number}
 */
MinStack.prototype.top = function() {
    return this.stack[this.stack.length-1];
};

/**
 * @return {number}
 */
MinStack.prototype.getMin = function() {
    return this.minStack[this.minStack.length-1];
};
```

##### [150.逆波兰表达式求值 ](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)

```js
var evalRPN = function (tokens) {
    const stack = []
    for (const item of tokens) {
        if (!isNaN(+item)) {
            stack.push(item)
        } else {
            let res = 0
            const top = parseInt(stack.pop()) //在栈中的位置靠上（被除数）
            const down = parseInt(stack.pop()) //靠下（除数）
            switch (item) {
                case '+':
                    res = top + down
                    break
                case '-':
                    res = down - top
                    break
                case '*':
                    res = top * down
                    break
                case '/':
                    res = parseInt(down / top)
                    break
            }
            stack.push(res)
        }
    }
    return stack[0]
};
```

##### [394. 字符串解码](https://leetcode-cn.com/problems/decode-string/)

给定一个经过编码的字符串，返回它解码后的字符串。

> 输入：s = "3[a]2[bc]"
> 输出："aaabcbc"

```js
var decodeString = function (s) {
    const stack = []
    for (let i = 0; i < s.length; i++) {
        const char = s[i]
        if (char !== ']') {
            stack.push(char)
        } else {
            let str = ''
            while (stack.length > 0) {
                const temp = stack.pop()
                if (temp !== '[') {
                    str = temp + str
                } else {
                    let num = ''
                    while (stack.length > 0) {
                        const tempNum = stack.pop() // 处理类似100的数字，此时栈中['1','0','0']
                        if (!isNaN(tempNum)) {
                            num = tempNum + num
                        } else {
                            stack.push(tempNum)
                            break
                        }
                    }
                    str = str.repeat(+num)
                    break
                }
            }
            stack.push(str)
        }
    }
    return stack.join('')
}
```

##### [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

```js
var inorderTraversal = function (root) { //递归写法
    if (root === null) {
        return []
    }
    const res = [];
    (function inOrder(root) {
        if (!root) {
            return
        }
        inOrder(root.left)
        res.push(root.val)
        inOrder(root.right)
    })(root);
    return res
};
```

```js

```

##### [133.克隆图](https://leetcode-cn.com/problems/clone-graph/)

