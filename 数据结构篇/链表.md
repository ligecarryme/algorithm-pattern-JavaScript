### 链表

#### 核心点

- null/nil 异常处理
- dummy node 哑巴节点
- 快慢指针
- 插入一个节点到排序链表
- 从一个链表中移除一个节点
- 翻转链表
- 合并两个链表
- 找到链表的中间节点

#### 练习

83. 删除排序链表中的重复元素 [remove-duplicates-from-sorted-list](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)

> 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。

```js
var deleteDuplicates = function(head) {
    let current = head;
    while(current !== null && current.next !== null){
        if(current.val === current.next.val){
            current.next = current.next.next;
        }else{
            current = current.next;
        }
    }
    return head;
};
```

递归写法

```js
var deleteDuplicates = function(head) {
    if(head === null || head.next === null){
        return head;
    }
    head.next = deleteDuplicates(head.next);
    return head.val === head.next.val ? head.next : head;
};
```

82.删除排序链表中的重复元素Ⅱ（删除重复数字的节点，只保留没有重复数字的节点）[remove-duplicates-from-sorted-list-ii](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)

> 给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中  没有重复出现的数字。

```js
var deleteDuplicates = function(head) {
    if (head === null || head.next === null) {
        return head;
    }
    let dummy = new ListNode(-1);
    dummy.next = head;
    let front = dummy;
    let back = head.next;
    while(back !== null){
        if(front.next.val !== back.val){
            front = front.next;
            back = back.next;
        } else {
            while(back!==null && front.next.val === back.val){
                back = back.next;
            }
            front.next = back;
            back = back === null ? null : back.next;
        }    
    }
    return dummy.next;
};
```

206.反转一个单链表（头插法）。[reverse-linked-list](https://leetcode-cn.com/problems/reverse-linked-list/)

> 输入: 1->2->3->4->5->NULL
> 输出: 5->4->3->2->1->NULL

```js
var reverseList = function(head) {
    if(head === null || head.next === null) return head;
    let dummy = new ListNode(-1);
    while(head !== null){
        let p = head.next;
        head.next = dummy.next;
        dummy.next = head;
        head = p;
    }
    return dummy.next;
};
```

92. 反转链表Ⅱ [reverse-linked-list-ii](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

反转从位置 *m* 到 *n* 的链表。请使用一趟扫描完成反转。**说明:**1 ≤ *m* ≤ *n* ≤ 链表长度。

> 输入: 1->2->3->4->5->NULL, m = 2, n = 4
> 输出: 1->4->3->2->5->NULL

```js
var reverseBetween = function(head, m, n) {
    let dummy = new ListNode(-1);
    dummy.next = head; //哑巴节点
    head = dummy;
    for(let i=m;i>1;i--){
        head = head.next; // 让head指向反转子列表的前一个节点
    }
    let pre = head.next; //指向子列表的第一个节点
    for(let j=m;j<n;j++){
        let post = pre.next; 
        pre.next = post.next; //头插法
        post.next = head.next;
        head.next = post;
    }
    return dummy.next;
};
```

21.合并两个有序链表 [merge-two-sorted-lists](https://leetcode-cn.com/problems/merge-two-sorted-lists/)，将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

> 输入：1->2->4, 1->3->4
> 输出：1->1->2->3->4->4

```js
// 迭代法
var mergeTwoLists = function(l1, l2) {
    let dummy = new ListNode(-1);
    let pre = dummy;
    while(l1 !== null && l2 !== null){
        if(l1.val <= l2.val){
            pre.next = l1;
            l1 = l1.next;
        }else{
            pre.next = l2;
            l2 = l2.next;
        }
        pre = pre.next;
    }
    pre.next = l1 === null ? l2 : l1;
    return dummy.next;
};
```

```js
//递归
var mergeTwoLists = function(l1, l2) {
    if(l1 === null){
        return l2;
    }else if(l2 === null){
        return l1;
    }else if(l1.val <= l2.val){
        l1.next = mergeTwoLists(l1.next,l2);
        return l1;
    }else{
        l2.next = mergeTwoLists(l1,l2.next);
        return l2;
    }
};
```

86.分隔链表 [分隔链表](https://leetcode-cn.com/problems/partition-list/) 

给定一个链表和一个特定值 *x*，对链表进行分隔，使得所有小于 *x* 的节点都在大于或等于 *x* 的节点之前。你应当保留两个分区中每个节点的初始相对位置。

> 输入: head = 1->4->3->2->5->2, x = 3
> 输出: 1->2->2->4->3->5

```js
var partition = function(head, x) {
    let biggerX = new ListNode(0);
    let post = biggerX;
    let smallerX = new ListNode(0);
    let pre = smallerX;
    let temp;
    while(head !== null){
        temp = head.next;
        if(head.val < x){
            pre.next = head;
            pre = pre.next;
        }else{
            post.next = head;
            post = post.next;
        }
        head = temp;
    }
    post.next = null; //最后一个的下一个指向为空，否则会出现环
    pre.next = biggerX.next;
    return smallerX.next;
};
```

